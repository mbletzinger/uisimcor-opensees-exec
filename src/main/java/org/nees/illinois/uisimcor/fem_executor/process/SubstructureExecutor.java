package org.nees.illinois.uisimcor.fem_executor.process;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.BlockingQueue;

import org.nees.illinois.uisimcor.fem_executor.config.DofIndexMagic;
import org.nees.illinois.uisimcor.fem_executor.config.dao.ProgramDao;
import org.nees.illinois.uisimcor.fem_executor.config.dao.SubstructureDao;
import org.nees.illinois.uisimcor.fem_executor.input.OpenSeesSG;
import org.nees.illinois.uisimcor.fem_executor.input.ScriptGeneratorI;
import org.nees.illinois.uisimcor.fem_executor.output.BinaryFileReader;
import org.nees.illinois.uisimcor.fem_executor.output.DataFormatter;
import org.nees.illinois.uisimcor.fem_executor.output.OutputFileMonitor;
import org.nees.illinois.uisimcor.fem_executor.output.WorkDirWatcher;
import org.nees.illinois.uisimcor.fem_executor.utils.MtxUtils;
import org.nees.illinois.uisimcor.fem_executor.utils.OutputFileException;
import org.nees.illinois.uisimcor.fem_executor.utils.PathUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class to execute an FEM program to statically analyze a substructure at one
 * step.
 * @author Michael Bletzinger
 */
public class SubstructureExecutor {
	/**
	 * Program configuration to run.
	 */
	private ProgramDao command;

	/**
	 * default wait.
	 */
	private final int defaultWait = 2000;

	/**
	 * Logger.
	 **/
	private final Logger log = LoggerFactory
			.getLogger(SubstructureExecutor.class);
	/**
	 * {@link ProcessManagement Wrapper} around command line executor.
	 */
	private ProcessManagement pm;
	/**
	 * Wait interval for checking thread for done. Default is 2 seconds
	 */
	private int waitInMillisecs = defaultWait;

	/**
	 * Working directory for FEM execution.
	 */
	private final String workDir;
	/**
	 * FEM execution script generator.
	 */
	private final ScriptGeneratorI scriptGen;
	/**
	 * Reformat the output for UI-SimCor.
	 */
	private final DataFormatter dformat;
	/**
	 * Results of a step command.
	 */
	private List<Double> rawDisp;
	/**
	 * Results of a step command.
	 */
	private List<Double> rawForce;

	/**
	 * Counter for debug messages.
	 */
	private int debugCnt = 0;
	/**
	 * Number of counts until reset.
	 */
	private final int maxCnt = 20;
	/**
	 * Monitors files generated by the FEM script.
	 */
	private final OutputFileMonitor ofm;
	/**
	 * Thread for the file monitor.
	 */
	private final Thread ofmThrd;

	/**
	 * @param progCfg
	 *            FEM program configuration parameters.
	 * @param scfg
	 *            Configuration for the substructure.
	 * @param configDir
	 *            Directory containing templates and configuration files..
	 * @param workDir
	 *            Directory to store temporary files.
	 * @param watcher
	 * Monitors the working directory for file changes.
	 */
	public SubstructureExecutor(final ProgramDao progCfg,
			final SubstructureDao scfg, final String configDir,
			final String workDir, final WorkDirWatcher watcher) {
		this.workDir = workDir;
		this.command = progCfg;
		this.dformat = new DataFormatter(scfg);
		this.scriptGen = new OpenSeesSG(configDir, scfg,
				progCfg.getTemplateDao());
		this.pm = new ProcessManagement(command.getExecutablePath(), command
				.getProgram().toString(), waitInMillisecs);
		DofIndexMagic magic = new DofIndexMagic(scfg.getDimension(), false, false);
		int numdofs = scfg.getNumberOfNodes() * magic.numberOfDofsPerNode();
		BinaryFileReader dispReader = new BinaryFileReader(PathUtils.append(workDir, "tmp_disp.out"), numdofs);
		BinaryFileReader forceReader = new BinaryFileReader(PathUtils.append(workDir, "tmp_forc.out"), numdofs);
		this.ofm = new OutputFileMonitor(dispReader, forceReader, watcher);
		this.ofmThrd = new Thread(ofm);
	}

	/**
	 * @return the workDir
	 */
	public final String getWorkDir() {
		return workDir;
	}

	/**
	 * @param command
	 *            the command to set
	 */
	public final void setCommand(final ProgramDao command) {
		this.command = command;
		pm.setCmd(command.getExecutablePath());
	}

	/**
	 * @param waitInMillisecs
	 *            the waitInMillisecs to set
	 */
	public final void setWaitInMillisecs(final int waitInMillisecs) {
		this.waitInMillisecs = waitInMillisecs;
	}

	/**
	 * 	 */
	public final void startSimulation() {
		pm.setWorkDir(workDir);
		try {
			pm.startExecute();
			ofmThrd.start();
			String init = scriptGen.generateInit();
			pm.getStdinQ().add(new QMessageT<String>(QMessageType.Setup, init));
		} catch (IOException e) {
			log.debug(pm.getCmd() + " failed to start", e);
		}
	}

	/**
	 * Send the next step command to the FEM program.
	 * @param step
	 *            Current step.
	 * @param displacements
	 *            Current displacement target.
	 */
	public final void startStep(final int step, final double[] displacements) {
		String stepCmnd = scriptGen.generateStep(step, displacements);
		pm.getStdinQ().add(new QMessageT<String>(QMessageType.Command, stepCmnd));
		debugCnt = 0;
	}

	/**
	 * Execution Polling function. Use this repeatedly inside a polling loop to
	 * transition the process to new execution states.
	 * @return True if the command has completed.
	 * @throws OutputFileException
	 *             If force values are missing,
	 */
	public final boolean stepIsDone() throws OutputFileException {
		BlockingQueue<QMessageT<List<Double>>> responses = ofm.getResponseQ();
		QMessageT<List<Double>> rspStr = responses.poll();
		if (rspStr == null) {
			if (debugCnt == maxCnt) {
				debugCnt = 0;
				log.debug("Still waiting for " + pm.getCmd());
			} else {
				debugCnt++;
			}
			return false;
		}
		if (rspStr.getType().equals(QMessageType.Exit)) {
			abort();
		}
		rawDisp = rspStr.getContent();
		log.debug("Raw Displacements " + MtxUtils.list2String(rawDisp));
		rspStr = responses.poll();
		if (rspStr == null) {
			throw new OutputFileException("Force values are missing");
		}
		rawForce = rspStr.getContent();
		log.debug("Raw Forces " + MtxUtils.list2String(rawForce));
		return true;
	}

	/**
	 * Abort the execution.
	 */
	public final void abort() {
		pm.abort();
		ofm.setQuit(true);
		ofmThrd.interrupt();
	}

	/**
	 * Return the displacements data set.
	 * @return double matrix
	 */
	public final double[] getDisplacements() {
		List<Double> result = dformat.filter(rawDisp);
		return MtxUtils.list2Array(result);
	}

	/**
	 * Return the forces data set.
	 * @return double matrix
	 */
	public final double[] getForces() {
		List<Double> result = dformat.filter(rawForce);
		return MtxUtils.list2Array(result);
	}
}
